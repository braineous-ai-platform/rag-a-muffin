# C. CGO Validation Guide

> **Audience:** Java developers using or extending CGO's safety layer
> **Goal:** Understand how CGO validates rule outputs (Proposals) to guarantee graph consistency before mutation

---

## 1. Overview

Validation is CGO’s **safety barrier**.

Before any mutation touches the graph, CGO verifies that all **Proposals** generated by a Rulepack form a:

- **coherent**,
- **consistent**, and
- **structurally safe**

delta set.

This ensures:

- No broken relationships
- No invalid fact/edge references
- No contradictory rule outcomes
- No malformed or missing data

Even if a developer writes a faulty rule, **CGO prevents corrupting the graph**.

---

## 2. Validation in the CGO Pipeline

Validation sits between execution and mutation:

```
Rulepack Execution → Proposal Set → Validation → Graph Mutation
```

If validation fails:

- No mutation occurs
- The service receives a **BindResult.notOk(...)**
- An explanatory message describes the structural issue

This is CGO's **fail-safe**.

---

## 3. ProposalValidator (Core Validator)

The **ProposalValidator** is the primary, built-in validator.
It enforces structural correctness across all proposals.

### What ProposalValidator Ensures

1. **Fact Validation**

   - Fact IDs must be non-null and stable
   - Payloads must be valid JSON
   - Required fields (if any) must exist (domain optional)

2. **Relationship Validation**

   - Every relationship must point to existing Facts
   - `fromId` and `toId` must not be null
   - Relationship payload must be valid JSON

3. **Topological Consistency**

   - Combined deltas must not create orphan nodes
   - No circular reference unless explicitly allowed
   - Conflicts between proposals are detected

4. **Internal Integrity Checks**

   - No duplicate fact IDs unless overwrite is explicitly allowed
   - Edge references must remain resolvable

If all checks pass → validation OK.
If any check fails → validation fails with a descriptive message.

---

## 4. Fact & Relationship Validator Rules (Advanced)

Developers may extend validation using two functional interfaces:

### 4.1 FactValidatorRule

```java
@FunctionalInterface
public interface FactValidatorRule {
    boolean validate(Fact fact, GraphView view);
}
```

Purpose:

- Enforce domain-specific constraints on facts
- Validate completeness or semantic correctness

Examples:

- Flight must have a departure airport
- Airport must have a 3-letter code

---

### 4.2 RelationshipValidatorRule

```java
@FunctionalInterface
public interface RelationshipValidatorRule {
    boolean validate(Relationship relationship, GraphView view);
}
```

Purpose:

- Validate constraints on edges (relationships)

Examples:

- `from` airport cannot equal `to` airport
- Route edges must include a valid `reason` field

---

## 5. StructureValidationResult / BindResult

The outcome of validation is reported using CGO's `BindResult`.

### Success

```java
BindResult.ok();
```

### Failure

```java
BindResult.notOk("Missing fact: AIRPORT:AUS");
```

BindResult may contain:

- A message
- Error code (optional)
- Diagnostic details

Applications treat failed BindResult as a **validation error**, not a system error.

---

## 6. Full Validation Flow

Below is the sequence CGO follows when validating proposals:

```
                +---------------------------+
                |       Rulepack Output     |
                |     (Set<Proposal>)       |
                +--------------+------------+
                               |
                               v
                +--------------+------------+
                |       ProposalValidator    |
                |  (Fact + Relationship +    |
                |   Topology checks)         |
                +--------------+------------+
                               |
                  OK           |
```
