# Validator Overview

The Validator is the correctness backbone of CGO.

Rules can be incomplete or misconfigured.  
But the **validator must always be right** — it protects the substrate, the graph, and the mutation pipeline.

This document provides developers with a clear understanding of:

- Why the validator exists
- How it fits into the bind → proposal → mutation flow
- The step-by-step “life of a proposal”
- A full working example (atomic + relational)
- The mental model for using validators safely

---

## 1. Why the Validator Exists

CGO separates **business intent** from **graph integrity**:

- **Rules**: business logic from the application.
- **Validator**: ensures rules do not violate structural invariants.
- **GraphBuilder**: performs mutations only after validation passes.

This guarantees:

- No accidental corruption
- No malformed nodes or edges
- Safe extension of rulepacks
- Deterministic behavior

---

## 2. Two Kinds of Validation

### A. Substrate Validation (before rules execute)

Ensures the input (`from`, `to`, `edge`) is structurally valid.

Checks include:

- Valid JSON
- Required fields
- Proper modes (atomic vs relational)
- Relationship consistency
- Graph-aware structure checks

If this fails → **abort immediately**.

---

### B. Proposal Validation (after rules execute)

Rules produce **proposals**.

Each proposal must satisfy:

- Relationship integrity
- Type compatibility
- Rulepack constraints
- No cycles unless allowed
- No broken references

If **any** proposal fails → **all proposals fail**.

Mutation happens only if _all_ proposals are valid.

---

## 3. The Life of a Proposal

### Step 1 — Input Arrives

Developer provides:

- `fromFact`
- `toFact`
- `edgeFact`

### Step 2 — Substrate Validator

Checks for:

- JSON validity
- ID and mode correctness
- Relationship validity
- Context compatibility

If all checks pass → continue.  
If not → stop.

### Step 3 — Rule Execution

Rules fire and generate:

- 0 to N proposals  
  (No mutation yet.)

### Step 4 — Proposal Validator

Each proposal is checked:

- Structure
- Relationship semantics
- Domain constraints
- Graph invariants

If any fail → reject all.

### Step 5 — Mutation

GraphBuilder mutates the graph only after every proposal passes.

---

## 4. Minimal Example

### fromFact

```json
{
  "id": "Airport:AUS",
  "kind": "Airport",
  "name": "Austin"
}
```

### toFact

```json
{
  "id": "Airport:DFW",
  "kind": "Airport",
  "name": "Dallas"
}
```

### edgeFact (relational)

```json
{
  "id": "Flight:AUS-DFW:001",
  "kind": "Flight",
  "from": "Airport:AUS",
  "to": "Airport:DFW"
}
```

## Pipeline Walkthrough

Below is how CGO processes the three input Facts (`from`, `to`, and `edge`) through every stage of the bind pipeline. This shows precisely where validation happens and when mutations are actually allowed.

---

### 1. Substrate Validation

This phase checks the _structural integrity_ of the input before **any** rules execute.

What CGO verifies here:

- **Valid JSON** for all three Facts
- **Correct modes**
  - `fromFact` → atomic
  - `toFact` → atomic
  - `edgeFact` → relational
- **Required fields** present
- **Edge connects valid IDs**
- **No contradictions** between the three Facts
- **Graph-aware checks** (e.g., an edge pointing to itself if not allowed)

If any check fails → **bind stops immediately**.

If everything is correct → CGO proceeds to the next stage.

---

### 2. Rule Execution

Once the substrate is confirmed valid:

- All rulepacks associated with this input execute.
- Rules run as pure functions.
- They produce **0 or more Proposals**.

A **Proposal** is a description of a desired graph change, such as:

- create a relationship
- update a Fact
- attach attributes
- enforce a derived constraint

At this stage:

➡️ **No mutation occurs.**  
➡️ CGO only _collects intentions_.

---

### 3. Proposal Validation

Every proposal generated by rules is now checked for correctness.

CGO ensures:

- The relationship defined by the proposal is **allowed**
- The direction is **valid**
- The types of `from` / `to` match expectations
- The proposal would not violate graph invariants
- The proposal doesn’t introduce disallowed cycles
- No dangling references or missing nodes
- Rulepack-level validation constraints pass

**Critical rule:**

> If any proposal fails, the _entire bind_ fails.  
> Mutations only occur if _all_ proposals are valid.

This is CGO’s transaction-like guarantee.

---

### 4. Mutation Phase (GraphBuilder)

Only after:

- Substrate is valid
- AND all proposals are valid

…the GraphBuilder applies mutations.

This is the **only** place where the graph changes.

Examples of what may be written into the graph:

- New edges
- Updated Fact attributes
- New nodes (if rules created them)
- Relationship registration
- Edge metadata

GraphBuilder performs mutations in a deterministic, ordered way so that:

- The graph remains consistent
- Mutation is all-or-nothing
- No partial writes can ever occur

---

### 5. Result

If everything succeeds:

- The graph now contains the new relationship
- All facts remain structurally sound
- The final graph state is guaranteed valid by design

For the example provided:

```text
Airport:AUS → Airport:DFW via Flight:AUS-DFW:001
```

---

## 6. Developer Mental Model

A simple mental model helps developers understand how CGO enforces safety:

### **Rules = suggestions**

Rules express what “should” happen based on business logic, but they are not trusted blindly.

### **Validator = referee**

The validator checks both the input and every proposed change.
It blocks anything unsafe, inconsistent, or structurally invalid.

### **GraphBuilder = final authority**

Only GraphBuilder can mutate the graph.
It executes mutations _only_ after validator approval.

Together, this produces a transaction-like, deterministic pipeline.

---

## 7. Why This Matters for Developers

CGO’s validator architecture ensures:

- **Safe rulepack evolution**
  Developers can add or modify rules without risking graph corruption.

- **Graph correctness across all domains**
  Whether you’re modeling airports, flights, finance entities, or clinical records.

- **Predictable behavior**
  The same input always produces the same validated outcome.

- **Simple onboarding**
  The entire validation system operates on JSON Facts and pure functions — easy to understand, easy to test.

- **Protection against logic bugs**
  Even if a rule is wrong, the validator prevents bad writes.

The validator is the **stability engine** of CGO:
it guarantees that as rules grow in complexity, the graph remains consistent, deterministic, and safe.

---
